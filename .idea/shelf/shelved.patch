Index: src/main/java/datastructures/worklists/ListFIFOQueue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package datastructures.worklists;\r\n\r\nimport cse332.exceptions.NotYetImplementedException;\r\nimport cse332.interfaces.worklists.FIFOWorkList;\r\n\r\nimport java.util.NoSuchElementException;\r\n\r\n/**\r\n * See cse332/interfaces/worklists/FIFOWorkList.java\r\n * for method specifications.\r\n */\r\npublic class ListFIFOQueue<E> extends FIFOWorkList<E> {\r\n    /*\r\n    We declare node variables head and tail for the linked list,\r\n    and a size variable to keep track of the size.\r\n     */\r\n    private Node head;\r\n    private Node tail;\r\n    private int size;\r\n\r\n    public ListFIFOQueue() {\r\n        //Default constructor with no value in the node.\r\n        head = new Node();\r\n        tail = new Node();\r\n        size = 0;\r\n\r\n        head.setNext(tail);\r\n        tail.setPrev(head);\r\n    }\r\n\r\n    @Override\r\n    public void add(E work) {\r\n        /*\r\n        The add method adds value to the end of the linked list.\r\n        We first store work into a Node variable temp. Then, we\r\n        check if tail's prev is head. If so, we append temp into\r\n        the back of the list. If not, we append temp after head.\r\n         */\r\n        Node temp = new Node(work);\r\n        if(tail.getPrev() != head) {\r\n            Node temp2 = tail.getPrev();\r\n            temp2.setNext(temp);\r\n            temp.setNext(tail);\r\n            temp.setPrev(temp2);\r\n            tail.setPrev(temp);\r\n        } else {\r\n            head.setNext(temp);\r\n            temp.setNext(tail);\r\n            temp.setPrev(head);\r\n            tail.setPrev(temp);\r\n        }\r\n        size++;\r\n    }\r\n\r\n    @Override\r\n    public E peek() {\r\n        /*\r\n        The peek method checks the first value of the linked list.\r\n        We check if head is null, and if head's next is tail. If so,\r\n        the linked list is empty, where we throw exception. Otherwise,\r\n        we return head's next node, as it is the first value of the list.\r\n         */\r\n        if(head != null && head.getNext() != tail) {\r\n                return head.getNext().getData();\r\n        } else {\r\n            throw new NoSuchElementException();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public E next() {\r\n        /*\r\n        The next method removes the first value of the linked list.\r\n        We first declare a temp variable to return the value we removed\r\n        from the linked list. Then, we check if head's next is tail. If so,\r\n        the linked list is empty, where we throw exception. Otherwise, we\r\n        declare a temp2 variable as head's next, and we set head's next to\r\n        temp2's next, and prev of temp2's next to head.\r\n         */\r\n        E temp;\r\n        if(head.getNext() != tail) {\r\n            Node temp2 = head.getNext();\r\n            temp = temp2.getData();\r\n\r\n            head.setNext(temp2.getNext());\r\n            temp2.getNext().setPrev(head);\r\n        } else {\r\n            throw new NoSuchElementException();\r\n        }\r\n        size--;\r\n        return temp;\r\n    }\r\n\r\n    @Override\r\n    public int size() {\r\n        //The size method checks the size of the linked list.\r\n        return this.size;\r\n    }\r\n\r\n    @Override\r\n    public void clear() {\r\n        /*\r\n        The clear method clears the linked list.\r\n        We set head node to null to clear the linked list.\r\n        Then, we set size to 0.\r\n         */\r\n        head = null;\r\n        size = 0;\r\n    }\r\n\r\n    public boolean hasWork() {\r\n        /*\r\n        We check if head is null. If head isn't null,\r\n        then it has work.\r\n         */\r\n        return head != null;\r\n    }\r\n\r\n    private class Node {\r\n        /*\r\n        This is the subclass Node we will use for the queue implementation.\r\n        We declare a generic variable data to keep track of the data,\r\n        and we declare node variables next and prev to keep track of the\r\n        next and prev nodes of each individual node.\r\n         */\r\n        private E data;\r\n        private Node next;\r\n        private Node prev;\r\n\r\n        //Default constructor, we set everything to null.\r\n        public Node() {\r\n            this.data = null;\r\n            this.next = null;\r\n            this.prev = null;\r\n        }\r\n\r\n        //Constructor with given data.\r\n        public Node(E dataValue) {\r\n            this.data = dataValue;\r\n            this.next = null;\r\n            this.prev = null;\r\n        }\r\n\r\n        //getData returns the data of the node.\r\n        public E getData() {\r\n            return this.data;\r\n        }\r\n\r\n        //getNext returns the next node.\r\n        public Node getNext() {\r\n            return this.next;\r\n        }\r\n\r\n        //getPrev returns the prev node.\r\n        public Node getPrev() {\r\n            return this.prev;\r\n        }\r\n\r\n        //setData changes the data of the current node.\r\n        public void setData(E dataValue) {\r\n            this.data = dataValue;\r\n        }\r\n\r\n        //setNext changes the next node.\r\n        public void setNext(Node nextN) {\r\n            this.next = nextN;\r\n        }\r\n\r\n        //setPrev changes the prev node.\r\n        public void setPrev(Node prevN) {\r\n            this.prev = prevN;\r\n        }\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/datastructures/worklists/ListFIFOQueue.java b/src/main/java/datastructures/worklists/ListFIFOQueue.java
--- a/src/main/java/datastructures/worklists/ListFIFOQueue.java	
+++ b/src/main/java/datastructures/worklists/ListFIFOQueue.java	
@@ -61,7 +61,7 @@
         we return head's next node, as it is the first value of the list.
          */
         if(head != null && head.getNext() != tail) {
-                return head.getNext().getData();
+            return head.getNext().getData();
         } else {
             throw new NoSuchElementException();
         }
@@ -173,3 +173,4 @@
     }
 }
 
+
Index: src/main/java/cse332/interfaces/worklists/FixedSizeFIFOWorkList.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package cse332.interfaces.worklists;\r\n\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\n\r\n/**\r\n * A subclass of FIFOWorkList that has a capacity. This subclass of WorkList can\r\n * be useful when performance is important; the limit on the number of elements\r\n * in the queue can allow the implementation to be faster.\r\n *\r\n * @param <E> the type of element in the worklist\r\n * @author Adam Blank\r\n */\r\npublic abstract class FixedSizeFIFOWorkList<E> extends FIFOWorkList<E>\r\n        implements Comparable<FixedSizeFIFOWorkList<E>> {\r\n    private final int capacity;\r\n\r\n    public FixedSizeFIFOWorkList(int capacity) {\r\n        if (capacity < 0) {\r\n            throw new IllegalArgumentException(\"capacity should be non-negative\");\r\n        }\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    /**\r\n     * Adds work to the worklist. This method should conform to any additional\r\n     * contracts that the particular type of worklist has.\r\n     *\r\n     * @param work the work to add to the worklist\r\n     * @throws IllegalStateException iff isFull()\r\n     * @precondition isFull() is false\r\n     */\r\n    @Override\r\n    public abstract void add(E work);\r\n\r\n    /**\r\n     * Returns a view of the ith element of the worklist. Since this worklist is\r\n     * a FIFO worklist, it has a well-defined order.\r\n     *\r\n     * @param i the index of the element to peek at\r\n     * @return the ith element in this worklist\r\n     * @throws NoSuchElementException    if hasWork() is false (this exception takes precedence over\r\n     *                                   all others)\r\n     * @throws IndexOutOfBoundsException if i < 0 or i >= size()\r\n     * @precondition 0 <= i < size()\r\n     * @postcondition the structure of this worklist remains unchanged\r\n     */\r\n    public abstract E peek(int i);\r\n\r\n    /**\r\n     * Replaces the ith element of this worklist with value. Since this worklist\r\n     * is a FIFO worklist it has a well-defined order.\r\n     *\r\n     * @param i     the index of the element to update\r\n     * @param value the value to update index i with\r\n     * @throws NoSuchElementException    if hasWork() is false (this exception takes precedence over\r\n     *                                   all others)\r\n     * @throws IndexOutOfBoundsException if i < 0 or i >= size()\r\n     * @precondition 0 <= i < size()\r\n     * @postcondition only the ith element of the structure is changed\r\n     */\r\n    public abstract void update(int i, E value);\r\n\r\n    /**\r\n     * This element returns the capacity of the worklist.\r\n     *\r\n     * @return the capacity of the worklist\r\n     */\r\n    public int capacity() {\r\n        return this.capacity;\r\n    }\r\n\r\n    /**\r\n     * Returns true iff this worklist cannot accommodate another element.\r\n     *\r\n     * @return true if this worklist is full\r\n     */\r\n    public boolean isFull() {\r\n        return size() >= this.capacity();\r\n    }\r\n\r\n    @Override\r\n    public Iterator<E> iterator() {\r\n        return new FixedSizeWorkListIterator();\r\n    }\r\n\r\n    private class FixedSizeWorkListIterator implements Iterator<E> {\r\n        int idx;\r\n\r\n        @Override\r\n        public boolean hasNext() {\r\n            return this.idx < size();\r\n        }\r\n\r\n        @Override\r\n        public E next() {\r\n            return FixedSizeFIFOWorkList.this.peek(this.idx++);\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/cse332/interfaces/worklists/FixedSizeFIFOWorkList.java b/src/main/java/cse332/interfaces/worklists/FixedSizeFIFOWorkList.java
--- a/src/main/java/cse332/interfaces/worklists/FixedSizeFIFOWorkList.java	
+++ b/src/main/java/cse332/interfaces/worklists/FixedSizeFIFOWorkList.java	
@@ -53,13 +53,14 @@
      *
      * @param i     the index of the element to update
      * @param value the value to update index i with
+     * @return
      * @throws NoSuchElementException    if hasWork() is false (this exception takes precedence over
      *                                   all others)
      * @throws IndexOutOfBoundsException if i < 0 or i >= size()
      * @precondition 0 <= i < size()
      * @postcondition only the ith element of the structure is changed
      */
-    public abstract void update(int i, E value);
+    public abstract E update(int i, E value);
 
     /**
      * This element returns the capacity of the worklist.
